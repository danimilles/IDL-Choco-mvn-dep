/*
 * generated by Xtext 2.19.0
 */
package es.us.isa.idl.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext

import java.io.File
import java.util.Map
import java.util.HashMap
import java.io.BufferedWriter
import java.io.FileWriter
import com.fasterxml.jackson.databind.ObjectMapper

import static es.us.isa.idl.generator.ReservedWords.RESERVED_WORDS;

import es.us.isa.idl.idl.GeneralClause
import es.us.isa.idl.idl.GeneralPredefinedDependency
import es.us.isa.idl.idl.Dependency;
import es.us.isa.idl.idl.ConditionalDependency;
import es.us.isa.idl.idl.impl.ConditionalDependencyImpl
import es.us.isa.idl.idl.impl.GeneralPredefinedDependencyImpl
import es.us.isa.idl.idl.impl.ArithmeticDependencyImpl
import es.us.isa.idl.idl.ArithmeticDependency
import es.us.isa.idl.idl.Operation
import es.us.isa.idl.idl.Param
import es.us.isa.idl.idl.impl.ParamImpl
import es.us.isa.idl.idl.OperationContinuation
import es.us.isa.idl.idl.impl.RelationalDependencyImpl
import es.us.isa.idl.idl.RelationalDependency
import es.us.isa.idl.idl.impl.GeneralTermImpl
import es.us.isa.idl.idl.GeneralTerm
import es.us.isa.idl.idl.GeneralPredicate
import org.chocosolver.solver.Model
import org.chocosolver.solver.constraints.Constraint
import org.chocosolver.solver.variables.Variable
import org.chocosolver.solver.variables.RealVar
import org.chocosolver.solver.variables.IntVar
import org.chocosolver.solver.variables.BoolVar
import java.util.List

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class IDLGenerator extends AbstractGenerator {

	val String constraintsFileName = "base_constraints.mzn"
	val String stringIntMappingFileName = "string_int_mapping.json"
	var String csp
	var String fullCsp
	var Integer stringToIntCounter
	var Map<String, Integer> stringIntMapping = new HashMap
	var model = new Model("problem");
	var String folderPath = "./idl_aux_files"
	
	def String getFolderPath() {
		return this.folderPath
	}
	
	def void setFolderPath(String folderPath) {
		this.folderPath = folderPath
	}

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		
	}
	
	def private String generateString(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		stringIntMapping.clear
		stringToIntCounter = 0
		
		fullCsp = "constraint ("
		for (dependency: resource.allContents.filter(Dependency).toIterable) {
			csp = "("
			if (dependency.dep.class == typeof(ConditionalDependencyImpl)) {
				writeConditionalDependency(dependency.dep as ConditionalDependency)
			} else if (dependency.dep.class == typeof(RelationalDependencyImpl)) {
				writeRelationalDependency(dependency.dep as RelationalDependency, true)
			} else if (dependency.dep.class == typeof(ArithmeticDependencyImpl)) {
				writeArithmeticDependency(dependency.dep as ArithmeticDependency, true)
			} else if (dependency.dep.class == typeof(GeneralPredefinedDependencyImpl)) {
				writePredefinedDependency(dependency.dep as GeneralPredefinedDependency)
			} else {
				throw new Exception("The dependency must be a conditional, an " + 
					"arithmetic, a relational or a predefined one")
			}
			csp += ")\n/\\\n"
			
			fullCsp += csp
			
		}
		fullCsp = fullCsp.substring(0, fullCsp.length-4)
		fullCsp += ");"
		if (fullCsp.contains("constrai);"))
			fullCsp = ""
		
		// Export constraints to IDL file
		var file = new File(folderPath + "/" + constraintsFileName)
		file.delete
		if (!file.exists) {
		  file.parentFile.mkdirs
		  file.createNewFile
		}
		var BufferedWriter out = new BufferedWriter(new FileWriter(file, false))
		
		out.append(fullCsp)
		out.flush
		out.close
		
		// Export string-int mapping to JSON
		var mappingFile = new File(folderPath + "/" + stringIntMappingFileName)
		mappingFile.delete
		if (!mappingFile.exists) {
		  mappingFile.parentFile.mkdirs
		  mappingFile.createNewFile
		}
        var BufferedWriter mappingOut = new BufferedWriter(new FileWriter(mappingFile, false))
        
		var ObjectMapper mapper = new ObjectMapper
		var String json = mapper.writerWithDefaultPrettyPrinter.writeValueAsString(stringIntMapping)
		
        mappingOut.append(json)
        mappingOut.flush
        return ""
	}
	
	/**
	 * Surround double with brackets if it's negative, and remove decimals (MiniZinc does not support floats)
	 */
	def private String parseDouble(String doubleValue) {
		val doubleWithoutDec = doubleValue.replaceAll("\\.\\d+", "")
		if (doubleWithoutDec.contains('-'))
			return ('(' + doubleWithoutDec + ')')
		return doubleWithoutDec
	}
	
	/**
	 * Remove and replace special characters from paramName
	 */
	def private String parseIDLParamName(String paramName) {
		var String parsedParamName = paramName.replaceAll("^\\[|\\]$", "").replaceAll("[\\.\\-\\/\\:\\[\\]]", "_")
		if (RESERVED_WORDS.contains(parsedParamName))
			parsedParamName += "_R"
		return parsedParamName
	}

	def private Integer stringToInt(String stringValue) {
		val Integer intMapping = stringIntMapping.get(stringValue)
		if (intMapping !== null) {
			return intMapping
		} else {
			stringIntMapping.put(stringValue, stringToIntCounter)
			return stringToIntCounter++
		}
	}
	
	
	/**
	 * Returns true if param is actually a ParamValueRelation. False if it is a Param
	 */
	def private boolean isParamValueRelation(Param param) {
		return param.stringValues.size !== 0 || param.patternString !== null || param.booleanValue !== null || param.doubleValue !== null
	}
	
	def private Constraint writePredicate(GeneralPredicate predicate) {
		var Constraint constraint = writeClause(predicate.firstClause)
		
		if (predicate.clauseContinuation !== null) {
			// Solve second element, which is a clause continuation containing a predicate
			if (predicate.clauseContinuation.logicalOp == "AND") {
				return model.and(constraint, writePredicate(predicate.clauseContinuation.additionalElements))
			} else if (predicate.clauseContinuation.logicalOp == "OR") {
				return model.or(constraint, writePredicate(predicate.clauseContinuation.additionalElements))
			} else {
				throw new Exception("The logical operator can only be AND or OR")
			}
		}
	}
	
	def private Constraint writeClause(GeneralClause clause) {
		var Constraint constraint = null;
		if (clause.predicate !== null) {
			constraint = writePredicate(clause.predicate)
			if (clause.not !== null){
				constraint = model.not(constraint)		
			}
		}
		
		// Solve firstElement, which can be a term, arithmetic dep, relational dep or predefined dep
		if (clause.firstElement !== null) {
			if (clause.firstElement.class == typeof(GeneralTermImpl)) { // param or param assignment
				val GeneralTerm term = (clause.firstElement as GeneralTerm)
				val Param param = (term.param as Param)

				var name = parseIDLParamName(param.name)
				var paramSetVar = model.boolVar(name + "Set").eq(1).boolVar
				var BoolVar paramVar = null
				
				if (isParamValueRelation(param)) {
					if (param.booleanValue !== null) {
						paramVar = model.boolVar(name).eq(Boolean.parseBoolean(param.booleanValue) ? 1 : 0).boolVar
					} else if (param.doubleValue !== null) {
						var IntVar intVar = model.intVar(name, Integer.MIN_VALUE, Integer.MAX_VALUE)
						paramVar = model.arithm(intVar, param.relationalOp, Integer.parseInt(parseDouble(param.doubleValue))).reify.eq(1).boolVar
					} else if (param.stringValues.size !== 0) {
						var IntVar intVar = model.intVar(name, Integer.MIN_VALUE, Integer.MAX_VALUE)
						var List<Constraint> constraints = newArrayList
						
						for (string: param.stringValues) {
							constraints.add(intVar.eq(stringToInt(string)).decompose)
						}
						paramVar = model.or(constraints).reify.eq(1).boolVar
					} else if (param.patternString !== null) {
						// TODO: Implement CSP mapping (none for now)
					}
				}
				
				var Constraint temp = constraint = model.and(paramSetVar, paramVar)
				if (term.not !== null){
					temp = model.not(temp)
				}
				
				if(constraint != null) {
					constraint = model.and(constraint, temp)
				} else {
					constraint = temp
				}				
			} else if(clause.firstElement.class == typeof(RelationalDependencyImpl)) {
				writeRelationalDependency(clause.firstElement as RelationalDependency, false)
			} else if(clause.firstElement.class == typeof(ArithmeticDependencyImpl)) {
				writeArithmeticDependency(clause.firstElement as ArithmeticDependency, false)
			} else if(clause.firstElement.class == typeof(GeneralPredefinedDependencyImpl)) {
				writePredefinedDependency(clause.firstElement as GeneralPredefinedDependency)
			} else {
				throw new Exception("The first element of a clause must be a term, an " + 
					"arithmetic dependency, a relational dependency or a predefined dependency")
			}
		}
		return constraint
	}
	
	def private void writeConditionalDependency(ConditionalDependency dep) {
		var condition = writePredicate(dep.condition)
		var consecuence = writePredicate(dep.consequence)
		model.ifThen(condition, consecuence);
	}

	def private Constraint writeRelationalDependency(RelationalDependency dep, boolean alone) {
		var nameParam1 = parseIDLParamName(dep.param1.name)
		var nameParam2 = parseIDLParamName(dep.param2.name)
		var param1SetVar = model.boolVar(nameParam1 + "Set").eq(1).boolVar
		var param2SetVar = model.boolVar(nameParam2 + "Set").eq(1).boolVar
		var ifParamsSet = model.and(param1SetVar, param2SetVar)
		var IntVar intVar1 = model.intVar(nameParam1, Integer.MIN_VALUE, Integer.MAX_VALUE)
		var IntVar intVar2 = model.intVar(nameParam2, Integer.MIN_VALUE, Integer.MAX_VALUE)
		var relatonialOperation = model.arithm(intVar1, dep.relationalOp, intVar2)
		if (alone){
			model.ifThen(ifParamsSet, relatonialOperation)
			return null
		} else {
			return model.and(ifParamsSet, relatonialOperation)
		}
	}
	
	def private void writeArithmeticDependency(ArithmeticDependency dep, boolean alone) {
		csp += "(("
		for (param: dep.eAllContents.filter(Param).toIterable) {
			csp += parseIDLParamName(param.name) + "Set==1 /\\ "
		}
		if (alone) {
			csp = csp.substring(0, csp.length-4) // Trim last " /\\ "
			csp += ") -> ("
		}
		writeOperation(dep.operation)
		csp += dep.relationalOp
		csp += parseDouble(dep.result)
		csp += "))"
	}
	
	def private void writeOperation(Operation operation) {
		if (operation.openingParenthesis === null) { // Alternative 1 of Operation
			csp += operation.firstParam.name
			writeOperationContinuation(operation.operationContinuation)
			
		} else { // Alternative 2 of Operation
			csp += "("
			writeOperation(operation.operation)
			csp += ")"
			if (operation.operationContinuation !== null) {
				writeOperationContinuation(operation.operationContinuation)
			}
			
		}
	}
	
	def private void writeOperationContinuation(OperationContinuation opCont) {
		csp += opCont.arithOp
		if (opCont.additionalParams.class == typeof(ParamImpl)) {
			csp += (opCont.additionalParams as Param).name
		} else {
			writeOperation(opCont.additionalParams as Operation)
		}
	}
	
	def private void writePredefinedDependency(GeneralPredefinedDependency dep) {		
		if (dep.not !== null)
			csp += "(not "
		csp += "("
		
		for (depElement: dep.predefDepElements) {
			csp += "("
			switch dep.predefDepType {
				case "Or": {
					writePredicate(depElement)
					csp += ") \\/ "
				} case "OnlyOne": {
					writeZeroOrOneOnlyOneElement(depElement, dep.predefDepElements)
					csp += ") /\\ "
				} case "AllOrNone": {
					writeAllOrNoneElement(depElement, dep.predefDepElements)
					csp += ") /\\ "
				} case "ZeroOrOne": {
					writeZeroOrOneOnlyOneElement(depElement, dep.predefDepElements)
					csp += ") /\\ "
				} default:
					throw new Exception("The predefined dependency can only be 'Or', " + 
						"'OnlyOne', 'AllOrNone' or 'ZeroOrOne'")
			}
		}
		if (dep.predefDepType.equals("OnlyOne")) { // If dep is OnlyOne, one more clause must be added
			csp += "("
			for (depElement: dep.predefDepElements) {
				csp += "("
				writePredicate(depElement)
				csp += ") \\/ "
			}
			csp = csp.substring(0, csp.length-4) // Trim last " /\\ " or " \\/ "
			csp += ")"
		} else { // Otherwise, last logicalOp must be removed
			csp = csp.substring(0, csp.length-4) // Trim last " /\\ " or " \\/ "
		}
		csp += ")"
		if (dep.not !== null)
			csp += ")"
	}
		
	def private void writeZeroOrOneOnlyOneElement(GeneralPredicate element, GeneralPredicate[] allElements) {
		writeZeroOrOneAllOrNoneElement(element, allElements, false, true)
	}
	
	def private void writeAllOrNoneElement(GeneralPredicate element, GeneralPredicate[] allElements) {
		writeZeroOrOneAllOrNoneElement(element, allElements, false, false)
		csp += ") /\\ ("
		writeZeroOrOneAllOrNoneElement(element, allElements, true, true)
	}
	
	def private void writeZeroOrOneAllOrNoneElement(GeneralPredicate element, GeneralPredicate[] allElements, boolean negateElement, boolean negateRemainingElements) {
		if (negateElement) { // For AllOrNone dependencies
			csp += "(not ("
			writePredicate(element)
			csp += ")) -> ("
		} else { // For ZeroOrOne, AllOrNone and OnlyOne dependencies
			csp += "("
			writePredicate(element)
			csp += ") -> ("
		}
		for (remainingElement: allElements) {
			if (!remainingElement.equals(element)) { // Include remaining elements in the consequence
				if (negateRemainingElements) { // For ZeroOrOne dependencies
					csp += "(not ("
					writePredicate(remainingElement)
					csp += ")) /\\ "
				} else { // For ZeroOrOne, AllOrNone and OnlyOne dependencies
					csp += "("
					writePredicate(remainingElement)
					csp += ") /\\ "
				}
			}
		}
		csp = csp.substring(0, csp.length-4) // Trim last " /\\ "
		csp += ")"
	}
	
}

